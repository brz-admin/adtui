# adtree.py
from textual.widgets import Tree
from ldap3 import Connection, ALL, SUBTREE
import threading
from queue import Queue

class ADTree(Tree):
    def __init__(self, conn, base_dn, page_size=100):
        super().__init__("AD Tree")
        self.conn = conn
        self.base_dn = base_dn
        self.page_size = page_size
        self.loaded_ous = set()
        self.loading_ous = set()
        self.object_queue = Queue()
        self.build_tree()

    def build_tree(self):
        """Build the initial tree structure with just top-level OUs."""
        try:
            # Start with the base DN as root
            root_node = self.root.add(f"ðŸ“ {self.base_dn}", expand=True)
            self._add_ou_children(root_node, self.base_dn)
        except Exception as e:
            print(f"Error building tree: {e}")

    def _add_ou_children(self, parent_node, parent_dn):
        """Add direct child OUs to the tree."""
        try:
            # Search for direct child OUs only
            self.conn.search(parent_dn, '(objectClass=organizationalUnit)',
                           attributes=['ou', 'distinguishedName'],
                           size_limit=1000)

            # Sort OUs alphabetically
            for ou in sorted(self.conn.entries, key=lambda x: str(x['ou']).lower()):
                ou_dn = ou.entry_dn
                if self._is_direct_child(ou_dn, parent_dn):
                    ou_name = str(ou['ou']) if 'ou' in ou else "Unknown OU"
                    ou_node = parent_node.add(f"ðŸ“ {ou_name}", expand=False)
                    ou_node.data = ou_dn
        except Exception as e:
            print(f"Error adding OU children for {parent_dn}: {e}")

    def _is_direct_child(self, child_dn, parent_dn):
        """Check if child_dn is a direct child of parent_dn."""
        child_components = child_dn.split(',')
        return len(child_components) > 1 and ','.join(child_components[1:]) == parent_dn

    def on_tree_node_expanded(self, event):
        """Handle OU expansion with background loading."""
        node = event.node
        if (node.data and
            node.data not in self.loaded_ous and
            node.data not in self.loading_ous):

            self.loading_ous.add(node.data)
            loading_node = node.add_leaf("ðŸ”„ Loading objects...")

            # Start background thread to load contents
            threading.Thread(
                target=self._load_ou_contents,
                args=(node, node.data, loading_node),
                daemon=True
            ).start()

    def _load_ou_contents(self, parent_node, ou_dn, loading_node):
        """Load OU contents in background with proper paged results handling."""
        try:
            # First add child OUs
            self._add_ou_children(parent_node, ou_dn)

            # Load objects with paged results
            cookie = None
            total_objects = 0
            max_pages = 50  # Safety limit to prevent infinite loading
            pages_loaded = 0

            while pages_loaded < max_pages:
                self.conn.search(
                    ou_dn,
                    '(&(objectClass=*)(!(objectClass=organizationalUnit))(objectCategory=*))',
                    attributes=['cn', 'objectClass'],
                    paged_size=self.page_size,
                    paged_cookie=cookie
                )

                if not self.conn.entries:
                    break

                # Process this page of results
                for entry in self.conn.entries:
                    if self._is_direct_child(entry.entry_dn, ou_dn):
                        self.object_queue.put((parent_node, entry))
                        total_objects += 1

                # Update loading message
                loading_node.label = f"ðŸ”„ Loading ({total_objects} objects...)"

                # Check if there are more pages
                if not self.conn.result.get('controls'):
                    break

                cookie = self.conn.result['controls']['1.2.840.113556.1.4.319']['value']['cookie']
                pages_loaded += 1

            # Remove loading node and mark as loaded
            parent_node.remove()
            self.loaded_ous.add(ou_dn)
            self.loading_ous.discard(ou_dn)

            # If we hit the max pages, add a message
            if pages_loaded == max_pages:
                parent_node.add_leaf(f"âš ï¸ Showing first {total_objects} objects (limit reached)")

            # Process queued objects
            self._process_object_queue()

        except Exception as e:
            print(f"Error loading OU contents for {ou_dn}: {e}")
            loading_node.label = f"âš ï¸ Error: {str(e)[:50]}..."
            self.loading_ous.discard(ou_dn)

    def _process_object_queue(self):
        """Process objects from the queue in the main thread."""
        try:
            while not self.object_queue.empty():
                parent_node, entry = self.object_queue.get_nowait()
                cn = str(entry['cn']) if 'cn' in entry else "Unknown"
                obj_classes = [str(cls).lower() for cls in entry['objectClass']]

                if 'user' in obj_classes and 'computer' not in obj_classes:
                    parent_node.add_leaf(f"ðŸ‘¤ {cn}")
                elif 'computer' in obj_classes:
                    parent_node.add_leaf(f"ðŸ’» {cn}")
                elif 'group' in obj_classes:
                    parent_node.add_leaf(f"ðŸ‘¥ {cn}")
        except Exception as e:
            print(f"Error processing object queue: {e}")

    def refresh_ou(self, node):
        """Refresh the contents of an OU."""
        if node.data and node.data in self.loaded_ous:
            # Clear existing objects (keep OUs)
            for child in list(node.children):
                if not child.data or not child.data.startswith('OU='):
                    node.remove(child)

            # Reload contents
            loading_node = node.add_leaf("ðŸ”„ Reloading objects...")
            threading.Thread(
                target=self._load_ou_contents,
                args=(node, node.data, loading_node),
                daemon=True
            ).start()

    def on_mount(self):
        """Set up periodic queue processing."""
        self.set_interval(0.1, self._process_object_queue)

